<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JerryWebBlog</title>
  
  <subtitle>面朝大海，春暖花开</subtitle>
  <link href="https://jerrywebleeblog.top/atom.xml" rel="self"/>
  
  <link href="https://jerrywebleeblog.top/"/>
  <updated>2021-06-10T13:31:37.943Z</updated>
  <id>https://jerrywebleeblog.top/</id>
  
  <author>
    <name>Jerry Web Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>继承</title>
    <link href="https://jerrywebleeblog.top/2021/06/07/10/43/20210607%E7%BB%A7%E6%89%BF/"/>
    <id>https://jerrywebleeblog.top/2021/06/07/10/43/20210607%E7%BB%A7%E6%89%BF/</id>
    <published>2021-06-07T02:43:51.000Z</published>
    <updated>2021-06-10T13:31:37.943Z</updated>
    
    <content type="html"><![CDATA[<p>​现每个类都有3个部分，第一部分是构造函数内的，这是供 实例化对象复制用的，第二部分是构造函数外的，直接通过点语法添加的，这是供类使 用的，实例化对象是访问不到的，第三部分是类的原型中的，实例化对象可以通过其原 型链间接地访问到，也是为供所有实例化对象所共用的。</p><h2 id="子类的原型对象类式继承"><a class="markdownIt-Anchor" href="#子类的原型对象类式继承"></a> 子类的原型对象——类式继承</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		现每个类都有3个部分，第一部分是构造函数内的，这是供 实例化对象复制用的，第二部分是构造函数外的，直接通过点语法添加的，这是供类使 用的，实例化对象是访问不到的，第三部分是类的原型中的，实例化对象可以通过其原 型链间接地访问到，也是为供所有实例化对象所共用的。&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git常用命令及常见场景下的Git操作</title>
    <link href="https://jerrywebleeblog.top/2021/05/23/10/58/20210523Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84Git%E6%93%8D%E4%BD%9C/"/>
    <id>https://jerrywebleeblog.top/2021/05/23/10/58/20210523Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84Git%E6%93%8D%E4%BD%9C/</id>
    <published>2021-05-23T02:58:30.000Z</published>
    <updated>2021-06-10T13:31:37.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git-四大分区"><a class="markdownIt-Anchor" href="#git-四大分区"></a> Git 四大分区</h3><ul><li>工作区(Working Area)</li><li>暂存区(Stage)</li><li>本地仓库(Local Repository)</li><li>远程仓库(Remote Repository)</li></ul><p><img src="/img/git1.png" alt="git" /></p><hr /><h3 id="git-操作流程图"><a class="markdownIt-Anchor" href="#git-操作流程图"></a> Git 操作流程图</h3><p><img src="/img/git2.png" alt="git操作流程图" /></p><blockquote><p>原图引自:<a href="https://blog.csdn.net/qq_35414779/article/details/82630079">Git 从原理到解决冲突</a></p></blockquote><hr /><h3 id="git-常用命令列表"><a class="markdownIt-Anchor" href="#git-常用命令列表"></a> Git 常用命令列表</h3><table><thead><tr><th style="text-align:center"><code>命令</code></th><th style="text-align:left"><code>含义</code></th></tr></thead><tbody><tr><td style="text-align:center"><code>git init</code></td><td style="text-align:left">初始化</td></tr><tr><td style="text-align:center"><code>git clone [url]</code></td><td style="text-align:left">复制远程仓库到本地</td></tr><tr><td style="text-align:center"><code>git remote add [origin] [url]</code></td><td style="text-align:left">将本地仓库关联到远程仓库</td></tr><tr><td style="text-align:center"><code>git remote rm [name]</code></td><td style="text-align:left">删除远程仓库</td></tr><tr><td style="text-align:center"><code>git remote set-url --push [name] [newUrl]</code></td><td style="text-align:left">修改远程仓库</td></tr><tr><td style="text-align:center"><code>git pull [remoteName] [localBranchName]</code></td><td style="text-align:left">拉取远程仓库</td></tr><tr><td style="text-align:center"><code>git push [remoteName] [localBranchName]</code></td><td style="text-align:left">推送到远程仓库</td></tr><tr><td style="text-align:center"><code>git push origin [localBranchName]:master</code></td><td style="text-align:left">提交本地分支<code>localBranchName</code>作为远程的<code>master</code>分支</td></tr><tr><td style="text-align:center"><code>git push origin [localBranchName]:[localBranchName]</code><br />或者<br /><code>git push origin [localBranchName]</code></td><td style="text-align:left">提交本地分支<code>localBranchName</code>作为远程的<code>localBranchName</code>分支</td></tr><tr><td style="text-align:center"><code>git branch</code></td><td style="text-align:left">查看本地分支</td></tr><tr><td style="text-align:center"><code>git branch -a</code></td><td style="text-align:left">查看本地分支和远程分支</td></tr><tr><td style="text-align:center"><code>git branch -r</code></td><td style="text-align:left">查看远程分支</td></tr><tr><td style="text-align:center"><code>git branch [name]</code></td><td style="text-align:left">创建本地分支,创建后并不会切换到该分支</td></tr><tr><td style="text-align:center"><code>git checkout -b [name]</code></td><td style="text-align:left">创建本地分支并切换到该分支</td></tr><tr><td style="text-align:center"><code>git checkout [name]</code></td><td style="text-align:left">切换到该分支</td></tr><tr><td style="text-align:center"><code>git merge [name]</code></td><td style="text-align:left">合并该分支到当前分支</td></tr><tr><td style="text-align:center"><code>git push origin [name]</code></td><td style="text-align:left">将本地分支推送到远程分支</td></tr><tr><td style="text-align:center"><code>git push origin :heads/[name]</code></td><td style="text-align:left">删除<code>name</code>远程分支</td></tr><tr><td style="text-align:center"><code>git tag</code></td><td style="text-align:left">查看所有<code>tag</code>信息</td></tr><tr><td style="text-align:center"><code>git tag [name]</code></td><td style="text-align:left">创建<code>tag</code>标签</td></tr><tr><td style="text-align:center"><code>git tag -d [name]</code></td><td style="text-align:left">删除<code>tag</code>标签</td></tr><tr><td style="text-align:center"><code>git tag -r</code></td><td style="text-align:left">查看远程 tag 标签</td></tr><tr><td style="text-align:center"><code>git push origin [tag]</code></td><td style="text-align:left">推送本地<code>tag</code>到远程仓库</td></tr><tr><td style="text-align:center"><code>git push origin :refs/tags/[name]</code></td><td style="text-align:left">删除远程标签</td></tr><tr><td style="text-align:center"><code>git commit -v</code></td><td style="text-align:left">当你用<code>-v</code>参数的时候可以看 commit 的差异</td></tr><tr><td style="text-align:center"><code>git pull origin --tags</code></td><td style="text-align:left">合并远程<code>tag</code>到本地</td></tr><tr><td style="text-align:center"><code>git push origin --tags</code></td><td style="text-align:left">推送本地 tag 到远程仓库</td></tr><tr><td style="text-align:center"><code>git tag -a [name] -m ['yourMessage']</code></td><td style="text-align:left">创建带注释的<code>tag</code></td></tr><tr><td style="text-align:center"><code>git status</code></td><td style="text-align:left">查看当前项目状态</td></tr><tr><td style="text-align:center"><code>git add .</code></td><td style="text-align:left">暂存修改</td></tr><tr><td style="text-align:center"><code>git commint -a/-m ['yourMessage']</code></td><td style="text-align:left">提交修改</td></tr><tr><td style="text-align:center"><code>git commit --amend ['yourMessage']</code></td><td style="text-align:left">对最近的一次提交注释信息进行修改，并重新提交</td></tr><tr><td style="text-align:center"><code>git remote show origin</code></td><td style="text-align:left">显示远程库<code>origin</code>里的资源</td></tr><tr><td style="text-align:center"><code>git checkout --track origin/dev</code></td><td style="text-align:left">切换到远程<code>dev</code>分支</td></tr><tr><td style="text-align:center"><code>git branch -D master develop</code></td><td style="text-align:left">删除本地库<code>develop</code>(未合并分支的强制删除)</td></tr><tr><td style="text-align:center"><code>git branch -d [branchName]</code></td><td style="text-align:left">删除已经合并过的分支</td></tr><tr><td style="text-align:center"><code>git push origin --delete [remoteBranchName]</code></td><td style="text-align:left">删除远程分支</td></tr><tr><td style="text-align:center"><code>git rm [fileName]</code></td><td style="text-align:left">从<code>git</code>中删除指定文件(从暂存区和工作区中删除)</td></tr><tr><td style="text-align:center"><code>git config --list</code></td><td style="text-align:left">查看配置列表</td></tr><tr><td style="text-align:center"><code>git ls-files</code></td><td style="text-align:left">查看已经被提交的文件</td></tr><tr><td style="text-align:center"><code>git ls-files -s</code></td><td style="text-align:left">查看保存在暂存区的文件,和 hash 值</td></tr><tr><td style="text-align:center"><code>git cat-file -p [暂存区文件hash值]</code></td><td style="text-align:left">显示保存在暂存区的文件的具体内容</td></tr><tr><td style="text-align:center"><code>git log</code></td><td style="text-align:left">查看你<code>commit</code>的日志</td></tr><tr><td style="text-align:center"><code>git log --pretty=oneline</code></td><td style="text-align:left">显示提交信息到一行</td></tr><tr><td style="text-align:center"><code>git diff</code></td><td style="text-align:left">查看尚未暂存的更新</td></tr><tr><td style="text-align:center"><code>git diff --cached/--staged</code></td><td style="text-align:left">查看哪写文件已暂存还没有提交，并显示文件具体的修改内容</td></tr><tr><td style="text-align:center"><code>git rm --cached [fileName]</code></td><td style="text-align:left">移除文件(只从暂存区中删除)</td></tr><tr><td style="text-align:center"><code>git rm -f [fileName]</code></td><td style="text-align:left">强行移除修改后文件(从暂存区和工作区中删除)</td></tr><tr><td style="text-align:center"><code>git diff --cached 或 $ git diff --staged</code></td><td style="text-align:left">查看尚未提交的更新</td></tr><tr><td style="text-align:center"><code>git stash push</code></td><td style="text-align:left">将文件给<code>push</code>到一个临时空间中</td></tr><tr><td style="text-align:center"><code>git stash pop</code></td><td style="text-align:left">将文件从临时空间<code>pop</code>下来</td></tr><tr><td style="text-align:center"><code>git stash list</code></td><td style="text-align:left">查看未完成的任务保存在栈中的任务列表</td></tr><tr><td style="text-align:center"><code>git pull</code></td><td style="text-align:left">本地与服务器端同步</td></tr><tr><td style="text-align:center"><code>git fetch</code></td><td style="text-align:left">相当于是从远程获取最新版本到本地，不会自动<code>merge</code></td></tr><tr><td style="text-align:center"><code>git commit -a -m [&quot;log_message&quot;]</code></td><td style="text-align:left">(<code>-a</code>是提交所有改动，<code>-m</code>是加入 log 信息) 本地修改同步至服务器端</td></tr><tr><td style="text-align:center"><code>git branch [branchName] master</code></td><td style="text-align:left">从主分支 master 创建<code>[branchName]</code>分支</td></tr><tr><td style="text-align:center"><code>git branch -m [oldBranchName] [newBranchName]</code></td><td style="text-align:left">将<code>[oldBranchName]</code>修改为<code>[newBranchName]</code></td></tr><tr><td style="text-align:center"><code>git checkout [branchName]/master</code></td><td style="text-align:left">切换到<code>[branchName]/master</code>分支</td></tr><tr><td style="text-align:center"><code>git config --global --unset[ user.name]</code></td><td style="text-align:left">删除全局配置的用户名</td></tr><tr><td style="text-align:center"><code>git config --global --unset [user.email]</code></td><td style="text-align:left">删除全局配置的 emai</td></tr><tr><td style="text-align:center"><code>mv [oldFileName] [newFileName]</code></td><td style="text-align:left">文件重命名</td></tr><tr><td style="text-align:center"><code>git reflog</code></td><td style="text-align:left">查看之前所有的提交记录，包括已经被删除的，在<code>git log</code>中不显示的</td></tr><tr><td style="text-align:center"><code>git stash apply stash [栈hash]</code></td><td style="text-align:left">根据存储在栈中的 hash 值取出未完成的任务</td></tr><tr><td style="text-align:center"><code>git remote set-head origin -d</code></td><td style="text-align:left">删除<code>origin/HEAD</code>指针，无影响</td></tr></tbody></table><p><code>git checkout [newBranch]</code>使用注意:每次切换分支前，确保当前分支必须得是干净的;在切换分支时，如果当前分支上有未暂存的修改(第一次)或者有未提交的暂存(第一次),分支可以切换成功,但是这种操作可能会污染其他分支.</p><hr /><h3 id="git-命令重命名简化"><a class="markdownIt-Anchor" href="#git-命令重命名简化"></a> git 命令重命名(简化)</h3><ul><li><p><code>git lg</code> – 格式化展示提交信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg <span class="string">&quot;log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %C(bold blue)%s%Creset %Cgreen(%cr) &lt;%an&gt;%Creset&#x27; --abbrev-commit --date=relative&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>git lga</code> – 格式化展示提交信息(实现的操作同上,命令名为<code>lga</code>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lga <span class="string">&quot;log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %C(bold blue)%s%Creset %Cgreen(%cr) &lt;%an&gt;%Creset&#x27; --abbrev-commit --date=relative&quot;</span></span><br></pre></td></tr></table></figure></li></ul><hr /><h3 id="常见场景-git-操作"><a class="markdownIt-Anchor" href="#常见场景-git-操作"></a> 常见场景 Git 操作</h3><h4 id="将当前修改的内容提交到新的分支上"><a class="markdownIt-Anchor" href="#将当前修改的内容提交到新的分支上"></a> 将当前修改的内容提交到新的分支上</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 步骤1：在当前分支上的修改暂存起来</span></span><br><span class="line">git stash</span><br><span class="line"><span class="comment"># 步骤2：暂存修改后，在本地新建分支（new_branch为新分支的名字）</span></span><br><span class="line">git checkout -b new_branch</span><br><span class="line"><span class="comment"># 步骤3：将暂存的修改放到新建分支中</span></span><br><span class="line">git stash pop</span><br><span class="line"><span class="comment"># 步骤4：</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m [<span class="string">&#x27;commit message&#x27;</span>]</span><br><span class="line"><span class="comment"># 步骤5：将提交的内容push到远程服务器</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><code>git stash</code>的作用是把工作区(必须是工作区中已经被<code>git</code>追踪到的文件)和索引中的内容暂时存到一个堆上，而且这个堆是和分支不相关的。切换分支后，依然可以看到并使用。</p><p>当正在进行项目中某一部分的工作处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。但你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是<code>git stash</code>命令。</p><p>“‘储藏”可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。</p><h4 id="实际项目中的创建新分支及合并操作"><a class="markdownIt-Anchor" href="#实际项目中的创建新分支及合并操作"></a> 实际项目中的创建新分支及合并操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 步骤1:创建子分支</span></span><br><span class="line">git checkout -b [newBranch]</span><br><span class="line"><span class="comment"># 步骤2:完成该分支的需求</span></span><br><span class="line"><span class="comment"># 步骤3:添加提交</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m [<span class="string">&#x27;commit message&#x27;</span>]</span><br><span class="line"><span class="comment"># 返回主分支合并子分子</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge [newBranch]</span><br><span class="line"><span class="comment"># 推送到远程仓库</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将子分支推送到远程仓库</span></span><br><span class="line"><span class="comment"># 记得推到远端之前先拉取最新代码</span></span><br><span class="line">git pull</span><br><span class="line">git checkout [newBranch]</span><br><span class="line">git push origin [newBranch] / git push -u origin [newBranch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果远程分支没有创建关联,使用下面的代码创建远程分支并关联到本地分支</span></span><br><span class="line">git branch --set-upstream [newBranch] origin/[newBranch]</span><br></pre></td></tr></table></figure><hr /><blockquote><p>详细内容请参考<a href="https://git-scm.com/docs">git 文档</a>;如有错误请在右侧导航处邮件联系,或者在下方评论区指出.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;git-四大分区&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#git-四大分区&quot;&gt;&lt;/a&gt; Git 四大分区&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;工作区(Working Area)&lt;/li&gt;
&lt;li&gt;暂存区(Stage)&lt;/li&gt;
&lt;li&gt;本</summary>
      
    
    
    
    <category term="前端" scheme="https://jerrywebleeblog.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Git" scheme="https://jerrywebleeblog.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式——原型设计模式</title>
    <link href="https://jerrywebleeblog.top/2021/05/22/00/21/20210522js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jerrywebleeblog.top/2021/05/22/00/21/20210522js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-05-21T16:21:20.000Z</published>
    <updated>2021-05-23T03:02:41.863Z</updated>
    
    <content type="html"><![CDATA[<p><strong>所谓设计模式，是复现问题模型的思想的一种具体表现。一个问题模型可能有多种表达形式，但是如何将这类相似模型用代码的形式表现出来用以处理实际问题，这就产生了设计模式，设计模式是问题模型的具象化</strong>。</p><p>javascript没有提供传统面向对象语言中类式继承,而是通过<strong>原型委托</strong>的方式来实现对象与对象之间的继承。</p><p>面向接口编程是设计模式中最重要的思想，但是在JavaScript中，面向接口编程的过程跟主流的静态类型语言不一样。</p><hr /><h2 id="动态类型语言和静态类型语言"><a class="markdownIt-Anchor" href="#动态类型语言和静态类型语言"></a> 动态类型语言和静态类型语言</h2><p>编程语言按照数据类型大体可以分为两类：<strong>静态类型语言</strong>和<strong>动态类型语言</strong>。</p><h3 id="静态类型语言"><a class="markdownIt-Anchor" href="#静态类型语言"></a> 静态类型语言：</h3><p>在编译时便已确定变量的类型。</p><h4 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点：</h4><ol><li>编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前避免程序运行期间有可能发生的一些错误。</li><li>在程序中明确地规定了数据类型，编译器还可以针对性的对程序进行优化，提高执行速度。</li></ol><h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点：</h4><ol><li>迫使程序员依照强契约来编写程序。</li><li>类型的声明增加更多代码，编程中这些细节会将程序员的经历从思考业务逻辑上分散开。</li></ol><h3 id="动态类型语言"><a class="markdownIt-Anchor" href="#动态类型语言"></a> 动态类型语言：</h3><p>其变量类型要到程序运行时，待变量被赋予某个值后，才会具有某种类型。</p><h4 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点：</h4><ol><li>代码量少，简洁，程序员可以将更多逻辑放在业务逻辑上面，专注逻辑表达，对阅读程序有帮助。</li></ol><h4 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点：</h4><ol><li>无法保证变量的类型。</li></ol><hr /><h2 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h2><p>同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。</p><p>多态背后的思想，是将“做什么”和“谁去做”以及“怎样去做”分离开，也就是将“不变的事物”与“可能改变的事物”分离开。要实现这一点，归根结底要先消除类型之间的耦合关系。</p><p>多态性实际上指的是对象的多态性。</p><p>使用<strong>继承</strong>得到多态效果，继承一般包括实现继承和接口继承。</p><p><strong>多态的最根本作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句</strong></p><p>利用对象的多态性，不必考虑各个对象接到消息后应该做什么，对象应该做什么并不是临时决定的，而是事先已经约定好的，每个对象该做什么，已经成为了该对象的一个方法，被安装在对象内部，每个对象负责他们自己的行为。所以这些都想可以根据同一个消息有条不紊的分别执行自己的方法。</p><p><strong>将行为分布在各个对象种，并让这些对象各自负责自己的行为，这正是面向对象设计的优点。</strong></p><hr /><h2 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h2><p>封装的目的是将数据隐藏，一般而言是封装数据和封装实现，更广义的封装，还包括封装类型和封装变化。</p><h3 id="封装数据"><a class="markdownIt-Anchor" href="#封装数据"></a> 封装数据</h3><p>在java种提供了 <code>private</code>，<code>public</code>，<code>protected</code>等关键字来提供不同的访问权限。但是JavaScript种没有该关键字，只能依赖于变量的作用域来实现封装特性，而且只能模拟出<code>private</code>，<code>public</code>两种封装性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _name = <span class="string">&#x27;Jerry&#x27;</span> <span class="comment">// 私有变量</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">getName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 共有方法</span></span><br><span class="line">      <span class="keyword">return</span> _name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.getName()) <span class="comment">// 输出：Jerry</span></span><br><span class="line"><span class="built_in">console</span>.log(myObject._name)     <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure><h3 id="封装实现"><a class="markdownIt-Anchor" href="#封装实现"></a> 封装实现</h3><p>封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。对象对他自己的行为负责。封装使得对象之间的耦合变得松散。对象之间只能通过对外的接口来通信。当我们修改一个对象时，可以随意的修改他的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。</p><h3 id="封装类型"><a class="markdownIt-Anchor" href="#封装类型"></a> 封装类型</h3><p>封装类型是<strong>静态类型语言</strong>种的一种重要的封装方式。</p><h3 id="封装变化"><a class="markdownIt-Anchor" href="#封装变化"></a> 封装变化</h3><p><strong>找到变化并封装之</strong></p><p>通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开，在系统演变的过程中，我们只需要替换那些容易变化的部分，如果这些是已经封装好的，替换起来也相对容易。可以最大程度的保证程序的稳定性和可扩展性。</p><hr /><h2 id="原型模式和基于原型继承的javascript对象系统"><a class="markdownIt-Anchor" href="#原型模式和基于原型继承的javascript对象系统"></a> 原型模式和基于原型继承的JavaScript对象系统</h2><p>在以类为中心的面向对象编程语言种，类和对象的关系可以 想象成铸模和铸件的关系，对象总是从类中创建而来。而在原型编程思想种，类并不是必须的，对象未必需要从类中创建而来，一个对象是通过克隆另一个对象所得到的。</p><p>原型不单是一种设计模式，也被称为一种编程泛型。</p><h3 id="使用克隆的原型模式"><a class="markdownIt-Anchor" href="#使用克隆的原型模式"></a> 使用克隆的原型模式</h3><p>从设计模式的角度讲，原型模式是用于创建对象的一种模式，如果我们想要创建一个对象，一种方法是先指定它的类型，然后通过类来创建这个对象。原型模式选择了另外一种方式，我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。</p><p>原型模式实现的关键，是语言本身是否提供了clone方法，ES5提供了<code>Object.create()</code>方法，可以用来克隆对象，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Plane = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.blood = <span class="number">100</span></span><br><span class="line">  <span class="built_in">this</span>.attackLevel = <span class="number">1</span></span><br><span class="line">  <span class="built_in">this</span>.defenseLevel = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plane = <span class="keyword">new</span> Plane()</span><br><span class="line">plane.blood = <span class="number">500</span></span><br><span class="line">plane.attackLevel = <span class="number">10</span></span><br><span class="line">plane.defenseLevel = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(plane);</span><br><span class="line"><span class="keyword">var</span> clonePlane = <span class="built_in">Object</span>.create(plane)</span><br><span class="line"><span class="built_in">console</span>.log(clonePlane.__proto__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在不支持Object.create()方法的浏览器中，可以使用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.create = <span class="built_in">Object</span>.create || <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    F.prototype = obj</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="克隆是创建对象的手段"><a class="markdownIt-Anchor" href="#克隆是创建对象的手段"></a> 克隆是创建对象的手段</h3><p>原型模式的真正目的并非在于需要得到一个一模一样的对象，而是提供了一种便捷的方式去创建某个类型的对象，克隆只是创建这个对象的过程和手段。</p><p>JavaScript 就是使用原型模式来搭建整个面向对象系统的。在JavaScript 语言中不存在类的概念，对象也并非从类中创建出来的，所有的JavaScript 对象都是从某个对象上克隆而来的。</p><h3 id="javascript中的原型继承"><a class="markdownIt-Anchor" href="#javascript中的原型继承"></a> JavaScript中的原型继承</h3><ol><li>所有的数据都是对象。</li><li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。</li><li>对象会记住它的原型。</li><li>如果对象无法响应某个请求，它会把这个请求沿着原型链继续查找。</li></ol><p>JavaScript 的函数既可以作为普通函数被调用，也可以作为构造器被调用。当使用new 运算符来调用函数时，此时的函数就是一个构造器。 用new 运算符来创建对象的过程，实际上也只是先克隆<code>Object.prototype</code> 对象，再进行一些其他额外操作的过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Jerry&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> objectFactory = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>) <span class="comment">// 删除参数数组的第一个值赋值给Constructor</span></span><br><span class="line">  <span class="comment">// console.log(Constructor);</span></span><br><span class="line">  obj.__proto__ = Constructor.prototype    <span class="comment">// 指向正确的原型,把Person函数的getName()方法给obj</span></span><br><span class="line">  <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>)  <span class="comment">// 借用外部传入的构造器给obj空对象设置name属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj);  <span class="comment">// Person &#123; name: &#x27;Jerry&#x27; &#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(ret);  <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;object&#x27;</span> ? ret : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = objectFactory(Person, <span class="string">&#x27;Jerry&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person1);</span><br><span class="line"><span class="built_in">console</span>.log(person2);</span><br></pre></td></tr></table></figure><p>ES6带来了新的语法Class。这让JavaScript看起来像是一门基于类的语言，但其背后仍是通过<strong>原型机制</strong>来创建对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;所谓设计模式，是复现问题模型的思想的一种具体表现。一个问题模型可能有多种表达形式，但是如何将这类相似模型用代码的形式表现出来用以处理实际问题，这就产生了设计模式，设计模式是问题模型的具象化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;javascript没有提供传统面</summary>
      
    
    
    
    <category term="前端" scheme="https://jerrywebleeblog.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://jerrywebleeblog.top/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://jerrywebleeblog.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="面向对象" scheme="https://jerrywebleeblog.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
